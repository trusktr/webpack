{"version":3,"sources":["../src/motor-html/base.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;;;AACA;;;;;;AAEA,QAAQ,GAAR,CAAY,8BAAZ;;AAEA,IAAM,eAAe,4BAA0B,OAAO,WAAjC,CAArB;;IAGM,a;;;;;;;;;;0CACgB;AAAA;;AACd;;AAEA,iBAAK,IAAL,GAAY,IAAZ,C;;;;;;;;;;;;;AAaA,iBAAK,oBAAL,GAA4B,IAA5B;AACA,iBAAK,KAAL,GAAa,sBAAY;AAAA,uBAAK,OAAK,oBAAL,GAA4B,CAAjC;AAAA,aAAZ,CAAb;AACH;;;+BAEM;AACH,iBAAK,wBAAL;AACH;;;;;;;;;;;;;;;;;;;;;;;iDAoBwB,mB,EAAqB;;AAE1C,gBAAI,CAAC,KAAK,IAAV,EAAgB;AACZ,oBAAI,uBAAuB,6CAA3B,EACI,KAAK,IAAL,GAAY,mBAAZ,CADJ,KAGI,KAAK,IAAL,GAAY,KAAK,0BAAL,EAAZ;;AAEJ,qBAAK,gBAAL;AACH;AACJ;;;;;;;qDAI4B;AACzB,kBAAM,IAAI,SAAJ,CAAc,oEAAd,CAAN;AACH;;;;;;;;;;uCAGS,KAAK,IAAL,CAAU,Y;;;AAChB,qCAAK,oBAAL;;;;;;;;;;;;;;;;;;EA/DoB,Y;;kBAAtB,a","file":"base.js","sourcesContent":["import 'document-register-element'\nimport makeWebComponentBaseClass from './web-component'\nimport Node from '../motor/Node'\n\nconsole.log(' --- motor-html-base module.')\n\nconst WebComponent = makeWebComponentBaseClass(window.HTMLElement)\n\nexport default\nclass MotorHTMLBase extends WebComponent {\n    createdCallback() {\n        super.createdCallback()\n\n        this.node = null // to hold the imperative API Node instance.\n\n        // XXX: \"this.mountPromise\" vs \"this.ready\":\n        // \"ready\" seems to be more intuitive on the HTML side because\n        // if the user has a reference to a motor-node or a motor-scene\n        // and it exists in DOM, then it is already \"mounted\" from the\n        // HTML API perspective. Maybe we can use \"mountPromise\" for\n        // the imperative API, and \"ready\" for the HTML API. For example:\n        //\n        // await $('motor-scene')[0].ready // When using the HTML API\n        // await node.mountPromise // When using the imperative API\n        //\n        // Or, maybe we can just use \".ready\" in both APIs?...\n        this._resolveReadyPromise = null\n        this.ready = new Promise(r => this._resolveReadyPromise = r)\n    }\n\n    init() {\n        this._associateImperativeNode()\n    }\n\n    /**\n     * This method creates the association between this MotorHTMLNode instance\n     * and the imperative Node instance.\n     *\n     * This method may get called by this.init, but can also be called by\n     * the Node class if Node is used imperatively. See Node#constructor.\n     *\n     * @private\n     *\n     * @param {Node} imperativeMotorNode The Node to associate with this\n     * MotorHTMLNode. This parameter is only used in Node#constructor, and this\n     * happens when using the imperative form infamous instead of the HTML\n     * interface of infamous. When the HTML interface is used, this gets called\n     * first without an imperativeMotorNode argument and the call to this in\n     * Node#constructor will then be a noop. Basically, either this gets called\n     * first by MotorHTMLNode, or first by Node, depending on which API is used\n     * first.\n     */\n    _associateImperativeNode(imperativeMotorNode) {\n        // console.log(' -- associating imperative node')\n        if (!this.node) {\n            if (imperativeMotorNode && imperativeMotorNode instanceof Node)\n                this.node = imperativeMotorNode\n            else\n                this.node = this._makeImperativeCounterpart()\n\n            this._signalWhenReady()\n        }\n    }\n\n    // This method should be overriden by child classes. It should return the\n    // imperative-side instance that the HTML-side class (this) corresponds to.\n    _makeImperativeCounterpart() {\n        throw new TypeError('This method should be implemented by class extening MotorHTMLBase.')\n    }\n\n    async _signalWhenReady() {\n        await this.node.mountPromise\n        this._resolveReadyPromise()\n    }\n}\n"]}