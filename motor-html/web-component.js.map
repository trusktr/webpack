{"version":3,"sources":["../src/motor-html/web-component.js"],"names":[],"mappings":"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","file":"web-component.js","sourcesContent":["import jss from '../jss'\n\n// Very very stupid hack needed for Safari in order for us to be able to extend\n// the HTMLElement class. See:\n// https://github.com/google/traceur-compiler/issues/1709\n//if (typeof window.HTMLElement != 'function') {\n    //const _HTMLElement = function HTMLElement(){}\n    //_HTMLElement.prototype = window.HTMLElement.prototype\n    //window.HTMLElement = _HTMLElement\n//}\n\n// XXX: we can improve by clearing items after X amount of time.\nconst classCache = new Map\n\nlet stylesheets = {}\nlet instanceCountByConstructor = {}\n\nfunction hasHTMLElementPrototype(constructor) {\n    if (!constructor) return false\n    if (constructor === HTMLElement) return true\n    else return hasHTMLElementPrototype(constructor.prototype)\n}\n\n/**\n * Creates a WebComponent base class dynamically, depending on which\n * HTMLElement class you want it to extend from. Extend from WebComponent when\n * making a new Custom Element class.\n *\n * @example\n * const WebComponent = makeWebComponentBaseClass(HTMLButtonElement)\n * class AwesomeButton extends WebComponent { ... }\n *\n * @param {Function} elementClass The class to that the generated WebComponent\n * base class will extend from.\n */\nexport default\nfunction makeWebComponentBaseClass(elementClass) {\n    if (!elementClass) elementClass = HTMLElement\n\n    if (!hasHTMLElementPrototype(elementClass)) {\n        throw new TypeError(\n            'The argument to makeWebComponentBaseClass must be a constructor that extends from or is HTMLElement.'\n        )\n    }\n\n    // if a base class that extends the given `elementClass` has already been\n    // created, return it.\n    if (classCache.has(elementClass))\n        return classCache.get(elementClass)\n\n    // otherwise, create it.\n\n    class WebComponent extends elementClass {\n        constructor() { super(); this.createdCallback() }\n        createdCallback() {\n            this._attached = false\n            this._initialized = false\n\n            //this.root....addEventListener('slotchange', function() {\n                //let slot = ...\n                //for (el in slot) {\n                    //el.slottedCallback(slot)\n                //}\n            //})\n        }\n\n        //slottedCallback(slot) {\n        //}\n\n        connectedCallback() { this.attachedCallback() }\n        attachedCallback() {\n            this._attached = true\n\n            if (!this._initialized) {\n                this._init()\n                this._initialized = true\n            }\n        }\n\n        _createStylesheet() {\n\n            if (!instanceCountByConstructor[this.constructor.name])\n                instanceCountByConstructor[this.constructor.name] = 0\n\n            instanceCountByConstructor[this.constructor.name] += 1\n\n            if (instanceCountByConstructor[this.constructor.name] === 1) {\n\n                // XXX create stylesheet inside animation frame?\n                stylesheets[this.constructor.name] =\n                    jss.createStyleSheet(this.getStyles()).attach()\n            }\n        }\n\n        get stylesheet() {\n            return stylesheets[this.constructor.name]\n        }\n\n        disconnectedCallback() { this.detachedCallback() }\n        async detachedCallback() {\n            this._attached = false\n\n            // XXX Deferr to the next tick before cleaning up in case the\n            // element is actually being re-attached somewhere else within this\n            // same tick (detaching and attaching is synchronous, so by\n            // deferring to the next tick we'll be able to know if the element\n            // was re-attached or not in order to clean up or not). Note that\n            // appendChild can be used to move an element to another parent\n            // element, in which case attachedCallback and detachedCallback\n            // both get called, and in which case we don't necessarily want to\n            // clean up. If the element gets re-attached before the next tick\n            // (for example, gets moved), then we want to preserve the\n            // associated stylesheet and other stuff that would be cleaned up\n            // by an extending class' _cleanUp method by not running the\n            // following this._deinit() call.\n            await Promise.resolve() // deferr to the next tick.\n\n            // As mentioned in the previous comment, if the element was not\n            // re-attached in the last tick (for example, it was moved to\n            // another element), then clean up.\n            //\n            // XXX (performance): Should we coordinate this._deinit() with the\n            // animation loop to prevent jank?\n            if (!this._attached && this._initialized) {\n                this._deinit()\n            }\n        }\n\n        _destroyStylesheet() {\n            instanceCountByConstructor[this.constructor.name] -= 1\n            if (instanceCountByConstructor[this.constructor.name] === 0) {\n                stylesheets[this.constructor.name].detach()\n                delete stylesheets[this.constructor.name]\n                delete instanceCountByConstructor[this.constructor.name]\n            }\n        }\n\n        /**\n         * This method should be implemented by extending classes.\n         * @abstract\n         */\n        getStyles() {\n            throw new Error('Your component must define a getStyles method, which returns the JSS-compatible JSON-formatted styling of your component.')\n        }\n\n        _init() {\n            this._createStylesheet()\n            this.classList.add(this.stylesheet.classes[this.constructor.name])\n            this.init()\n        }\n        init() { /* to be defined by child class */ }\n\n        _deinit() {\n            // XXX: We can clean up the style after some time, for example like 1\n            // minute, or something, instead of instantly.\n            this._destroyStylesheet()\n            this._initialized = false\n            this.deinit()\n        }\n        deinit() { /* to be defined by child class */ }\n    }\n\n    classCache.set(elementClass, WebComponent)\n    return WebComponent\n}\n"]}