{"version":3,"sources":["../src/motor/Motor.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AAEA;;;;AAIA,IAAI,kBAAkB,KAAtB;;IAEM,K;AACF,qBAAc;AAAA;;AACV,aAAK,QAAL,GAAgB,KAAhB,C;AACA,aAAK,IAAL,GAAY,IAAZ,C;AACA,aAAK,qBAAL,GAA6B,KAA7B;AACA,aAAK,eAAL,GAAuB,EAAvB;AACA,aAAK,kBAAL,GAA0B,mBAA1B;AACH;;;;;;;;;;;;;;;;oBAoBS,S;;;;;qCAXF,KAAK,qB;;;;;;;;;AAET,qCAAK,qBAAL,GAA6B,IAA7B;;oCAEK,e;;;;;;uCACK,8B;;;AACN,kDAAkB,IAAlB;;;;;;;AAKE,yC,GAAY,SAAZ,SAAY,YAAa;AAC3B,0CAAK,QAAL,GAAgB,IAAhB;;AAEA,0CAAK,eAAL,CAAqB,SAArB;AACA,0CAAK,YAAL,CAAkB,SAAlB;;;AAGA,wCAAI,MAAK,eAAL,CAAqB,MAAzB,EACI,MAAK,IAAL,GAAY,sBAAsB,SAAtB,CAAZ,CADJ,KAEK;AACD,8CAAK,IAAL,GAAY,IAAZ;AACA,8CAAK,qBAAL,GAA6B,KAA7B;AACH;;AAED,0CAAK,QAAL,GAAgB,KAAhB;AACH,iC;;AAED,qCAAK,IAAL,GAAY,sBAAsB,SAAtB,CAAZ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sCAyCU,E,EAAI;AACd,gBAAI,OAAO,EAAP,IAAa,UAAjB,EACI,MAAM,IAAI,KAAJ,CAAU,iCAAV,CAAN;;AAEJ,iBAAK,eAAL,CAAqB,IAArB,CAA0B,EAA1B;;;AAGA,gBAAI,CAAC,KAAK,qBAAV,EACI,KAAK,mBAAL;;AAEJ,mBAAO,EAAP;AACH;;;yCAEgB,E,EAAI;AACjB,iBAAK,eAAL,CAAqB,MAArB,CAA4B,KAAK,eAAL,CAAqB,OAArB,CAA6B,EAA7B,CAA5B,EAA8D,CAA9D;AACH;;;wCAEe,S,EAAW;AAAA;AAAA;AAAA;;AAAA;AACvB,gEAAiB,KAAK,eAAtB,4GAAuC;AAAA,wBAA9B,IAA8B;;AACnC,yBAAK,SAAL;AACH;AAHsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAI1B;;;6CAEoB,I,EAAM;AACvB,gBAAI,CAAC,KAAK,kBAAL,CAAwB,GAAxB,CAA4B,IAA5B,CAAL,EACI,KAAK,kBAAL,CAAwB,GAAxB,CAA4B,IAA5B;AACP;;;;;;;+CAIsB,I,EAAM;AACzB,iBAAK,kBAAL,CAAwB,MAAxB,CAA+B,IAA/B;AACH;;;qCAEY,S,EAAW;AAAA;AAAA;AAAA;;AAAA;AACpB,iEAAmB,KAAK,kBAAxB,iHAA4C;AAAA;;AAAA,wBAAlC,IAAkC;;AACxC,yBAAK,OAAL,CAAa,SAAb;AACH;AAHmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIpB,iBAAK,kBAAL,CAAwB,KAAxB;AACH;;;;;;;;kBAIU,IAAI,KAAJ,E","file":"Motor.js","sourcesContent":["import documentReady from 'awaitbox/dom/documentReady'\n\nimport {\n    //animationFrame,\n} from './Utility'\n\nlet documentIsReady = false\n\nclass Motor {\n    constructor() {\n        this._inFrame = false // true when inside a requested animation frame.\n        this._rAF = null // the current animation frame, or null.\n        this._animationLoopStarted = false\n        this._allRenderTasks = []\n        this._nodesToBeRendered = new Map\n    }\n\n    /**\n     * Starts an rAF loop and runs the render tasks in the _renderTasks stack.\n     * As long as there are tasks in the stack, the loop continues. When the\n     * stack becomes empty due to removal of tasks, the rAF stops and the app\n     * sits there doing nothing -- silence, crickets.\n     */\n    async _startAnimationLoop() {\n        if (this._animationLoopStarted) return\n\n        this._animationLoopStarted = true\n\n        if (!documentIsReady) {\n            await documentReady()\n            documentIsReady = true\n        }\n\n        // DIRECT ANIMATION LOOP ///////////////////////////////////\n        // So now we can render after the scene is mounted.\n        const motorLoop = timestamp => {\n            this._inFrame = true\n\n            this._runRenderTasks(timestamp)\n            this._renderNodes(timestamp)\n\n            // If any tasks are left to run, continue the animation loop.\n            if (this._allRenderTasks.length)\n                this._rAF = requestAnimationFrame(motorLoop)\n            else {\n                this._rAF = null\n                this._animationLoopStarted = false\n            }\n\n            this._inFrame = false\n        }\n\n        this._rAF = requestAnimationFrame(motorLoop)\n\n        // ANIMATION LOOP USING WHILE AND AWAIT ///////////////////////////////////\n        //this._rAF = true\n        //let timestamp = null\n        //while (this._rAF) {\n            //timestamp = await animationFrame()\n            //this._inFrame = true\n\n            //this._runRenderTasks(timestamp)\n            //this._renderNodes(timestamp)\n\n            //// If any tasks are left to run, continue the animation loop.\n            //if (!this._allRenderTasks.length) {\n                //this._rAF = null\n                //this._animationLoopStarted = false\n            //}\n\n            //this._inFrame = false\n        //}\n    }\n\n    /**\n     * When a render tasks is added a new rAF loop will be started if there\n     * isn't one currently.\n     *\n     * A render task is simply a function that will be called over and over\n     * again, in the Motor's animation loop. That's all, nothing special.\n     * However, if a Node setter is used inside of a render task, then the Node\n     * will tell Motor that it needs to be re-rendered, which will happen at\n     * the end of the current frame. If a Node setter is used outside of a\n     * render task (i.e. outside of the Motor's animation loop), then the Node\n     * tells Motor to re-render the Node on the next animation loop tick.\n     * Basically, regardless of where the Node's setters are used (inside or\n     * outside of the Motor's animation loop), rendering always happens inside\n     * the loop.\n     *\n     * @param {Function} fn The render task to add.\n     * @return {Function} A reference to the render task. Useful for saving to\n     * a variable so that it can later be passed to Motor.removeRenderTask().\n     */\n    addRenderTask(fn) {\n        if (typeof fn != 'function')\n            throw new Error('Render task must be a function.')\n\n        this._allRenderTasks.push(fn)\n\n        // If the render loop isn't started, start it.\n        if (!this._animationLoopStarted)\n            this._startAnimationLoop()\n\n        return fn\n    }\n\n    removeRenderTask(fn) {\n        this._allRenderTasks.splice(this._allRenderTasks.indexOf(fn), 1)\n    }\n\n    _runRenderTasks(timestamp) {\n        for (let task of this._allRenderTasks) {\n            task(timestamp)\n        }\n    }\n\n    _setNodeToBeRendered(node) {\n        if (!this._nodesToBeRendered.has(node))\n            this._nodesToBeRendered.set(node)\n    }\n\n    // currently unused, as the list is cleared after each frame.\n    // TODO: prevent GC by clearing a linked list instead of Array, Set or Map?\n    _unsetNodeToBeRendered(node) {\n        this._nodesToBeRendered.delete(node)\n    }\n\n    _renderNodes(timestamp) {\n        for (let [node] of this._nodesToBeRendered) {\n            node._render(timestamp)\n        }\n        this._nodesToBeRendered.clear()\n    }\n}\n\n// export a singleton instance rather than the class directly.\nexport default new Motor\n"]}