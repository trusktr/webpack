{"version":3,"sources":["../src/motor/Node.js"],"names":[],"mappings":"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","file":"Node.js","sourcesContent":["import 'geometry-interfaces'\nimport Motor from './Motor'\nimport MotorHTMLNode from '../motor-html/node'\n\nconsole.log(' -- Node module ?????!')\n\n/**\n * Manages a DOM element. Exposes a set of recommended APIs for working with\n * DOM efficiently.\n */\nclass ElManager {\n    constructor(element) {\n        this.element = element\n    }\n\n    /**\n     * @param {Array.string} classes An array of class names to add to the\n     * managed element.\n     *\n     * Note: updating class names with `el.classList.add()` won't thrash the\n     * layout. See: http://www.html5rocks.com/en/tutorials/speed/animations\n     */\n    setClasses (...classes) {\n        if (classes.length) this.element.classList.add(...classes)\n        return this\n    }\n}\n\nclass XYZValues {\n    constructor(x = 0, y = 0, z = 0) {\n        this._x = x\n        this._y = y\n        this._z = z\n    }\n\n    // override this on the instance to run logic on a property change.\n    onChanged() {}\n\n    set x(value) {\n        this._x = value\n        this.onChanged()\n    }\n    get x() { return this._x }\n\n    set y(value) {\n        this._y = value\n        this.onChanged()\n    }\n    get y() { return this._y }\n\n    set z(value) {\n        this._z = value\n        this.onChanged()\n    }\n    get z() { return this._z }\n}\n\nexport default\nclass Node {\n\n    /**\n     * @constructor\n     *\n     * @param {Object} initialProperties Properties object -- see example\n     *\n     * @example\n     * var node = new Node({\n     * })\n     */\n    constructor (initialProperties = {}, _motorHtmlNode) {\n        // The presence of the _motorHtmlNode signifies that the HTML interface\n        // is being used, otherwise the imperative interface here is being\n        // used.\n\n        // DOM representation of Node\n        // TODO: remove this and handle it in the \"DOMRenderer\"\n        this._el = new ElManager(\n            _motorHtmlNode || this._makeElement()\n        )\n        this._el.element._associateImperativeNode(this)\n\n        this._mounted = false;\n\n        this._parent = null // default to no parent.\n        this._children = [];\n        this._scene = null // stores a ref to this Node's root Scene.\n\n        // Property Cache, with default values\n        this._properties = {\n\n            // XXX: remove these in favor of storing them directly in the\n            // DOMMatrix?\n            position: new XYZValues(0, 0, 0),\n            rotation: new XYZValues(0, 0, 0),\n\n            // TODO: handle scale\n            scale: new XYZValues(1, 1, 1),\n\n            // TODO, handle origin, needs a setter/getter pair.\n            origin: new XYZValues(0.5, 0.5, 0.5),\n\n            align: new XYZValues(0, 0, 0),\n            mountPoint: new XYZValues(0, 0, 0),\n            sizeMode: new XYZValues('absolute', 'absolute', 'absolute'),\n            absoluteSize: new XYZValues(0, 0, 0),\n            proportionalSize: new XYZValues(1, 1, 1),\n\n            transform: new window.DOMMatrix,\n\n            style: {\n                opacity: 1,\n            },\n        };\n\n        const self = this\n        const propertyChange = function() {\n            self._needsToBeRendered()\n        }\n        this._properties.position.onChanged = propertyChange\n        this._properties.rotation.onChanged = propertyChange\n        this._properties.scale.onChanged = propertyChange\n        this._properties.origin.onChanged = propertyChange\n        this._properties.align.onChanged = propertyChange\n        this._properties.mountPoint.onChanged = propertyChange\n        this._properties.sizeMode.onChanged = propertyChange\n        this._properties.absoluteSize.onChanged = propertyChange\n        this._properties.proportionalSize.onChanged = propertyChange\n\n        this.properties = initialProperties\n\n        // an internal promise that resolves when this Node finally belongs to\n        // a scene graph with a root Scene. The resolved value is the root\n        // Scene.\n        //\n        // TODO: Reset this._scenePromise when the node is removed from it's\n        // scene, or instead make _scenePromise a function that returns a\n        // promise waiting for the next scene that the node will belong to, and\n        // returns the existing promise if currently attached on a scene. For\n        // now, this only works for the first scene that this Node is attached\n        // to (which is not ultimately what we want).\n        this._resolveScenePromise = null\n        this._scenePromise = new Promise(r => this._resolveScenePromise = r)\n\n        // Provide the user a promise that resolves when this Node is attached\n        // to a tree and when this Node's eventual root Scene is mounted.\n        // Users can await this in order to do something after this Node is\n        // mounted in a scene graph that is live in the DOM.\n        // _resolveMountPromise holds the current _mountPromise's resolve\n        // method.\n        //\n        // TODO: Maybe we should rename this to `.ready`, matching with the\n        // HTML API. See motor-html/node createdCallback.\n        // TODO: We need to reset this when a Node is removed, as it will be\n        // mounted again if it is ever added back into a scene graph. For now,\n        // this only works on this Node's first mount.\n        this._resolveMountPromise = null\n        this._mountPromise = new Promise(r => this._resolveMountPromise = r)\n\n        this._waitForSceneThenResolveMountPromise()\n\n        this._init()\n    }\n\n    /**\n     * @private\n     */\n    _init() {\n        this._needsToBeRendered()\n    }\n\n    /**\n     * @private\n     */\n    _makeElement() {\n        return new MotorHTMLNode\n    }\n\n    /**\n     * @private\n     * Get a promise for the node's eventual scene.\n     */\n    _getScenePromise() {\n        if (!this._scene && !this._scenePromise)\n            this._scenePromise = new Promise(r => this._resolveScenePromise = r)\n\n        return this._scenePromise\n    }\n\n    /**\n     * @private\n     */\n    async _waitForSceneThenResolveMountPromise() {\n\n        // TODO: this conditional check should work with child classes who's\n        // constructor is no longer named \"Node\". This should not fire for\n        // Scene or child classes of Scene.\n        if (this.constructor.name == 'Node') {\n            await this._getScenePromise()\n            await this._scene.mountPromise\n\n            // TODO TODO: also wait for this._mounted so this.element is actually\n            // mounted in the DOM.\n            this._resolveMountPromise(true)\n        }\n\n    }\n\n    /**\n     * @readonly\n     *\n     * TODO: needs to be overriden for Scene, because Scene mounts/unmounts\n     * differently.\n     */\n    get mountPromise() {\n        if (!this._mounted && !this._mountPromise) {\n            this._mountPromise = new Promise(r => this._resolveMountPromise = r)\n            this._waitForSceneThenResolveMountPromise()\n        }\n\n        return this._mountPromise\n    }\n\n    /**\n     * this._parent is protected (node's can access other node._parent).\n     * The user should use the addChild methods, which automatically handles\n     * setting a parent.\n     *\n     * @readonly\n     */\n    get parent() {\n        return this._parent\n    }\n\n    /**\n     * @readonly\n     */\n    get children() {\n        // return a new array, so that the user modifying it doesn't affect\n        // this node's actual children.\n        return [...this._children]\n    }\n\n    /**\n     * @readonly\n     */\n    get element() {\n        return this._el.element\n    }\n\n    /**\n     * Get the Scene that this Node is in, null if no Scene. This is recursive\n     * at first, then cached.\n     *\n     * This traverses up the scene graph tree starting at this Node and finds\n     * the root Scene, if any. It caches the value for performance. If this\n     * Node is removed from a parent node with parent.removeChild(), then the\n     * cache is invalidated so the traversal can happen again when this Node is\n     * eventually added to a new tree. This way, if the scene is cached on a\n     * parent Node that we're adding this Node to then we can get that cached\n     * value instead of traversing the tree.\n     *\n     * @readonly\n     */\n    get scene() {\n        // NOTE: this._scene is initally null, created in the constructor.\n\n        // if already cached, return it.\n        if (this._scene) return this._scene\n\n        // if the parent node already has a ref to the scene, use that.\n        if (this._parent && this._parent._scene) {\n            this._scene = this._parent._scene\n\n            return this._scene\n        }\n\n        // otherwise call the scene getter on the parent, which triggers\n        // traversal up the scene graph in order to find the root scene (null\n        // if none).\n        else {\n            if (this.constructor.name == 'Scene') this._scene = this\n            else if (this._parent) this._scene = this._parent.scene\n\n            return this._scene\n        }\n    }\n\n    /**\n     * Set the position of the Node.\n     *\n     * @param {Object} newValue\n     * @param {number} [newValue.x] The x-axis position to apply.\n     * @param {number} [newValue.y] The y-axis position to apply.\n     * @param {number} [newValue.z] The z-axis position to apply.\n     */\n    set position(newValue) {\n        if (!(newValue instanceof Object))\n            throw new TypeError('Invalid value for Node#position.')\n\n        if (typeof newValue.x != 'undefined') this._properties.position._x = newValue.x\n        if (typeof newValue.y != 'undefined') this._properties.position._y = newValue.y\n        if (typeof newValue.z != 'undefined') this._properties.position._z = newValue.z\n\n        this._needsToBeRendered()\n    }\n    get position() {\n        return this._properties.position\n    }\n\n    /**\n     * @param {Object} newValue\n     * @param {number} [newValue.x] The x-axis rotation to apply.\n     * @param {number} [newValue.y] The y-axis rotation to apply.\n     * @param {number} [newValue.z] The z-axis rotation to apply.\n     *\n     * XXX: We should we also provide a setRotationAxis method to rotate about\n     * a particular axis? Or, maybe if a fourth `w` property is specified then\n     * x, y, and z can define a rotation axis and w be the angle.\n     */\n    set rotation(newValue) {\n        if (!(newValue instanceof Object))\n            throw new TypeError('Invalid value for Node#rotation.')\n\n        if (typeof newValue.x != 'undefined') this._properties.rotation._x = newValue.x\n        if (typeof newValue.y != 'undefined') this._properties.rotation._y = newValue.y\n        if (typeof newValue.z != 'undefined') this._properties.rotation._z = newValue.z\n\n        this._needsToBeRendered()\n    }\n    get rotation() {\n        return this._properties.rotation\n    }\n\n    /**\n     * @param {Object} newValue\n     * @param {number} [newValue.x] The x-axis scale to apply.\n     * @param {number} [newValue.y] The y-axis scale to apply.\n     * @param {number} [newValue.z] The z-axis scale to apply.\n     *\n     * TODO: scale is not handled yet.\n     */\n    set scale(newValue) {\n        if (!(newValue instanceof Object))\n            throw new TypeError('Invalid value for Node#scale.')\n\n        if (typeof newValue.x != 'undefined') this._properties.scale._x = newValue.x\n        if (typeof newValue.y != 'undefined') this._properties.scale._y = newValue.y\n        if (typeof newValue.z != 'undefined') this._properties.scale._z = newValue.z\n\n        this._needsToBeRendered()\n    }\n    get scale() {\n        return this._properties.scale\n    }\n\n    /**\n     * Set this Node's opacity.\n     *\n     * @param {number} opacity A floating point number between 0 and 1\n     * (inclusive). 0 is fully transparent, 1 is fully opaque.\n     */\n    set opacity(opacity) {\n        if (!isRealNumber(opacity)) throw new Error('Expected a real number for Node#opacity.')\n        this._properties.style.opacity = opacity;\n        this._needsToBeRendered()\n    }\n    get opacity() {\n        return this._properties.style.opacity\n    }\n\n    /**\n     * Set the size mode for each axis. Possible size modes are \"absolute\" and \"proportional\".\n     *\n     * @param {Object} newValue\n     * @param {number} [newValue.x] The x-axis sizeMode to apply.\n     * @param {number} [newValue.y] The y-axis sizeMode to apply.\n     * @param {number} [newValue.z] The z-axis sizeMode to apply.\n     */\n    set sizeMode(newValue) {\n        if (!(newValue instanceof Object))\n            throw new TypeError('Invalid value for Node#sizeMode.')\n\n        if (typeof newValue.x != 'undefined') this._properties.sizeMode._x = newValue.x\n        if (typeof newValue.y != 'undefined') this._properties.sizeMode._y = newValue.y\n        if (typeof newValue.z != 'undefined') this._properties.sizeMode._z = newValue.z\n\n        this._needsToBeRendered()\n    }\n    get sizeMode() {\n        return this._properties.sizeMode\n    }\n\n    /**\n     * @param {Object} newValue\n     * @param {number} [newValue.x] The x-axis absoluteSize to apply.\n     * @param {number} [newValue.y] The y-axis absoluteSize to apply.\n     * @param {number} [newValue.z] The z-axis absoluteSize to apply.\n     */\n    set absoluteSize(newValue) {\n        if (!(newValue instanceof Object))\n            throw new TypeError('Invalid value for Node#absoluteSize.')\n\n        if (typeof newValue.x != 'undefined') this._properties.absoluteSize._x = newValue.x\n        if (typeof newValue.y != 'undefined') this._properties.absoluteSize._y = newValue.y\n        if (typeof newValue.z != 'undefined') this._properties.absoluteSize._z = newValue.z\n\n        this._needsToBeRendered()\n    }\n    get absoluteSize() {\n        return this._properties.absoluteSize\n    }\n\n    /**\n     * Get the actual size of the Node. This can be useful when size is\n     * proportional, as the actual size of the Node depends on querying the DOM\n     * for the size of the Node's DOM element relative to it's parent.\n     *\n     * @readonly\n     *\n     * @return {Array.number} An Oject with x, y, and z properties, each\n     * property representing the computed size of the x, y, and z axes\n     * respectively.\n     *\n     * TODO: traverse up the tree to find parent size when this Node's size is\n     * proportional?\n     */\n    get actualSize() {\n        let actualSize = {}\n\n        if (this._properties.sizeMode.x === 'absolute') {\n            actualSize.x = this._properties.absoluteSize.x\n        }\n        else if (this._properties.sizeMode.x === 'proportional') {\n            // TODO: avoid getComputedStyle as it causes a layout thrash.\n            actualSize.x = parseInt(getComputedStyle(this._el.element).getPropertyValue('width'))\n        }\n\n        if (this._properties.sizeMode.y === 'absolute') {\n            actualSize.y = this._properties.absoluteSize.y\n        }\n        else if (this._properties.sizeMode.y === 'proportional') {\n            actualSize.y = parseInt(getComputedStyle(this._el.element).getPropertyValue('height'))\n        }\n\n        if (this._properties.sizeMode.z === 'absolute') {\n            actualSize.z = this._properties.absoluteSize.z\n        }\n        else if (this._properties.sizeMode.z === 'proportional') {\n            //actualSize.z = parseInt(getComputedStyle(this._el.element).getPropertyValue('height'))\n            actualSize.z = 0 // TODO\n        }\n\n        return actualSize\n    }\n\n    /**\n     * Set the size of a Node proportional to the size of it's parent Node. The\n     * values are a real number between 0 and 1 inclusive where 0 means 0% of\n     * the parent size and 1 means 100% of the parent size.\n     *\n     * @param {Object} newValue\n     * @param {number} [newValue.x] The x-axis proportionalSize to apply.\n     * @param {number} [newValue.y] The y-axis proportionalSize to apply.\n     * @param {number} [newValue.z] The z-axis proportionalSize to apply.\n     */\n    set proportionalSize(newValue) {\n        if (!(newValue instanceof Object))\n            throw new TypeError('Invalid value for Node#proportionalSize.')\n\n        if (typeof newValue.x != 'undefined') this._properties.proportionalSize._x = newValue.x\n        if (typeof newValue.y != 'undefined') this._properties.proportionalSize._y = newValue.y\n        if (typeof newValue.z != 'undefined') this._properties.proportionalSize._z = newValue.z\n\n        this._needsToBeRendered()\n    }\n    get proportionalSize() {\n        return this._properties.proportionalSize\n    }\n\n    /**\n     * Set the alignment of the Node. This determines at which point in this\n     * Node's parent that this Node is mounted.\n     *\n     * @param {Object} newValue\n     * @param {number} [newValue.x] The x-axis align to apply.\n     * @param {number} [newValue.y] The y-axis align to apply.\n     * @param {number} [newValue.z] The z-axis align to apply.\n     */\n    set align(newValue) {\n        if (!(newValue instanceof Object))\n            throw new TypeError('Invalid value for Node#align.')\n\n        if (typeof newValue.x != 'undefined') this._properties.align._x = newValue.x\n        if (typeof newValue.y != 'undefined') this._properties.align._y = newValue.y\n        if (typeof newValue.z != 'undefined') this._properties.align._z = newValue.z\n\n        this._needsToBeRendered()\n    }\n    get align() {\n        return this._properties.align\n    }\n\n    /**\n     * Set the mount point of the Node. TODO: put \"mount point\" into words.\n     *\n     * XXX possibly rename to \"anchor\" to avoid confusion with Scene.mount?\n     * Could also segway to anchors system like Qt QML.\n     *\n     * @param {Object} newValue\n     * @param {number} [newValue.x] The x-axis mountPoint to apply.\n     * @param {number} [newValue.y] The y-axis mountPoint to apply.\n     * @param {number} [newValue.z] The z-axis mountPoint to apply.\n     */\n    set mountPoint(newValue) {\n        if (!(newValue instanceof Object))\n            throw new TypeError('Invalid value for Node#mountPoint.')\n\n        if (typeof newValue.x != 'undefined') this._properties.mountPoint._x = newValue.x\n        if (typeof newValue.y != 'undefined') this._properties.mountPoint._y = newValue.y\n        if (typeof newValue.z != 'undefined') this._properties.mountPoint._z = newValue.z\n\n        this._needsToBeRendered()\n    }\n    get mountPoint() {\n        return this._properties.mountPoint\n    }\n\n    /**\n     * Set all properties of the Node in one method.\n     *\n     * XXX: Should we change size so it matches structure here and on the node?\n     *\n     * @param {Object} properties Properties object - see example\n     *\n     * @example\n     * node.properties = {\n     *   classes: ['open'],\n     *   position: [200, 300, 0],\n     *   rotation: [3, 0, 0],\n     *   scale: [1, 1, 1],\n     *   size: {\n     *     mode: ['absolute', 'proportional'],\n     *     absolute: [300, null],\n     *     proportional: [null, .5]\n     *   },\n     *   opacity: .9\n     * }\n     */\n    set properties (properties = {}) {\n        // Classes\n        if (properties.classes)\n            this._el.setClasses(properties.classes);\n\n        // Position\n        if (properties.position)\n            this.position = properties.position\n\n        // Rotation\n        if (properties.rotation)\n            this.rotation = properties.rotation\n\n        // Scale\n        if (properties.scale)\n            this.scale = properties.scale\n\n        // Align\n        if (properties.align)\n            this.align = properties.align\n\n        // Size Modes\n        if (properties.sizeMode)\n            this.sizeMode = properties.sizeMode\n\n        // Absolute Size\n        if (properties.absoluteSize)\n            this.absoluteSize = properties.absoluteSize\n\n        // Proportional Size\n        if (properties.proportionalSize)\n            this.proportionalSize = properties.proportionalSize\n\n        // Opacity\n        if (properties.style) {\n            if (typeof properties.style.opacity != 'undefined')\n                this.opacity = properties.opacity\n        }\n\n        this._needsToBeRendered()\n    }\n    // no need for a properties getter.\n\n    /*\n     * Trigger a re-render for this node (wait until mounted if not nounted\n     * yet).\n     *\n     * TODO: We need to render one time each time mountPromise is resolved, not\n     * just this one time as currently in constructor's call to this._init.\n     *\n     * XXX If a setter is called over and over in a render task before the node\n     * is mounted, then each tick will cause an await this.mountPromise, and\n     * eventually all the bodies will fire all at once. I don't think we want\n     * this to happen.\n     */\n    async _needsToBeRendered() {\n        if (!this._mounted) {\n            await this.mountPromise\n        }\n        Motor._setNodeToBeRendered(this)\n        if (!Motor._inFrame) Motor._startAnimationLoop()\n    }\n\n    /**\n     * Add a child node to this Node.\n     *\n     * @param {Node} childNode The child node to add.\n     */\n    addChild (childNode) {\n        if (! (childNode instanceof Node))\n            throw new Error('Node.addChild expects the childNode argument to be a Node instance.')\n\n        // We cannot add Scenes to Nodes, for now.\n        //\n        // TODO: If someone extends Scene, constructor.name is different. We\n        // need to catch those cases too, without using instanceof Scene in\n        // order to avoid a circular dependency in this module.\n        // Idea: maybe we can traverse the prototype chain looking for each\n        // constructor.name.\n        if (childNode.constructor.name == 'Scene') {\n            throw new Error(`\n                A Scene cannot currently be added to another Node.\n                This may change in the future. For now, just mount\n                a new Scene onto an HTMLElement (which can be the\n                element held by a Node).\n            `)\n        }\n\n        // Do nothing if the child Node is already added to this Node.\n        //\n        // After adding a Node to a parent using this imperative API, the\n        // MotorHTMLNode ends up calling addChild on this Node's parent a second time\n        // in the element's attachedCallback, but the code stops at this line (which is\n        // good).\n        // TODO: prevent the second call altogether.\n        if (childNode._parent === this) return\n\n        if (childNode._parent)\n            childNode._parent.removeChild(childNode)\n\n        // Add parent\n        childNode._parent = this;\n\n        // Add to children array\n        this._children.push(childNode);\n\n        // Pass this parent node's Scene reference (if any, checking this cache\n        // first) to the new child and the child's children.\n        //\n        // NOTE: Order is important: this needs to happen after previous stuff\n        // in this method, so that the childNode.scene getter works.\n        if (childNode._scene || childNode.scene) {\n            childNode._resolveScenePromise(childNode._scene)\n            childNode._giveSceneRefToChildren()\n        }\n\n        this._mountChildElement(childNode)\n\n        return this\n    }\n\n    /**\n     * @private\n     * This method to be called only when this Node has this.scene.\n     * Resolves the _scenePromise for all children of the tree of this Node.\n     */\n    _giveSceneRefToChildren() {\n        for (let childNode of this._children) {\n            childNode._scene = this._scene\n            childNode._resolveScenePromise(childNode._scene)\n            childNode._giveSceneRefToChildren();\n        }\n    }\n\n    /**\n     * Add all the child nodes in the given array to this node.\n     *\n     * @param {Array.Node} nodes The nodes to add.\n     */\n    addChildren(nodes) {\n        nodes.forEach(node => this.addChild(node))\n        return this\n    }\n\n    /**\n     * Remove a child node from this node. Silently fails if the node doesn't\n     * exist, etc.\n     *\n     * XXX Should this be silent? Or should we throw?\n     *\n     * @param {Node} childNode The node to remove.\n     */\n    removeChild(childNode) {\n        let thisHasChild = this._children.indexOf(childNode) >= 0\n\n        if (childNode instanceof Node && thisHasChild) {\n            childNode._parent = null\n            childNode._scene = null // not part of a scene anymore.\n            childNode._scenePromise = null // reset so that it can be awaited again for when the node is re-mounted.\n            childNode._mounted = false\n            childNode._mountPromise = null // reset so that it can be awaited again for when the node is re-mounted.\n\n            // Remove from children array\n            this._children.splice(this._children.indexOf(childNode), 1);\n\n            this._detachElement(childNode)\n        }\n\n        return this\n    }\n\n    /**\n     * Remove all the child nodes in the given array from this node.\n     *\n     * @param {Array.Node} nodes The nodes to remove.\n     */\n    removeChildren(nodes) {\n        nodes.forEach(node => this.removeChild(node))\n        return this\n    }\n\n    /**\n     * @readonly\n     * @return {number} How many children this Node has.\n     */\n    get childCount() {\n        return this._children.length\n    }\n\n    _render(timestamp) {\n        // applies the transform matrix to the element's style property.\n        // TODO: We shouldn't need to re-calculate the whole matrix every render?\n        this._setMatrix3d(this._calculateMatrix());\n\n        // TODO move to DOMRenderer\n        this._applySize()\n        this._applyStyles()\n\n        //this._renderChildren()\n\n        return this\n    }\n\n    _mountChildElement(childNode) {\n        // If Node's HTML element isn't mounted.. mount it.\n        // TODO move to DOMRenderer\n        if (! childNode._mounted) {\n            if (childNode._parent) {\n\n                // TODO: camera\n                // Mount to parent if parent is a Node\n                // if (childNode._parent instanceof Node) {\n                    if (childNode._el.element.parentNode !== childNode._parent._el.element)\n                        childNode._parent._el.element.appendChild(childNode._el.element);\n                    childNode._mounted = true;\n\n                // Mount to camera if top level Node\n                // } else {\n                //   //scene.camera.element.appendChild(childNode._el);\n                //   childNode._mounted = true;\n                // }\n            }\n        }\n    }\n\n    _detachElement(childNode) {\n        // TODO: move this out, into DOMRenderer\n\n        // XXX Only remove the childNode _el if it has an actual parent\n        if (childNode._el.element.parentNode)\n            childNode._el.element.parentNode.removeChild(childNode._el.element)\n    }\n\n    _renderChildren() {\n        // Render Children\n        // TODO: move this out, into DOMRenderer/WebGLRenderer:\n        // We don't need to render children explicitly (recursing through the\n        // tree) because the DOMRenderer or WebGLRenderer will know what to do\n        // with nodes in the scene graph.\n        // For example, in the case of the DOMRenderer, we only need to update\n        // this Node's transform matrix, then the renderer figures out the rest\n        // (i.e. the browser uses it's nested-DOM matrix caching). DOMRenderer\n        // or WebGLRenderer can decide how to most efficiently update child\n        // transforms and how to update the scene. Node._render here will be\n        // just a way of updating the state of this Node only.\n        for (let child of this._children) {\n            child._render();\n        }\n    }\n\n    /**\n     * [applySize description]\n     *\n     * @method\n     * @private\n     * @memberOf Node\n     */\n    _applySize () {\n        var mode = this._properties.sizeMode;\n        var absolute = this._properties.absoluteSize;\n        var proportional = this._properties.proportionalSize;\n\n        if (mode.x === 'absolute')\n            this._applyStyle('width', `${absolute.x}px`);\n        else if (mode.x === 'proportional')\n            this._applyStyle('width', `${proportional.x * 100}%`);\n\n        if (mode.y === 'absolute')\n            this._applyStyle('height', `${absolute.y}px`);\n        else if (mode.y === 'proportional')\n            this._applyStyle('height', `${proportional.y * 100}%`);\n\n        //TODO z axis\n        //if (mode.z === 'absolute')\n            //this._applyStyle('height', `${absolute.z}px`);\n        //else if (mode.z === 'proportional')\n            //this._applyStyle('height', `${proportional.z * 100}%`);\n    }\n\n    /**\n     * [applyTransform description]\n     *\n     * @method\n     * @private\n     * @memberOf Node\n     *\n     * TODO: instead of calculating the whole matrix here all at once (which\n     * gets called each _render()), apply rotation, translation, etc, directly\n     * to the matrix individually when the user gives us those values. It might be\n     * more performant. It will also let the user apply x,y,z rotation in their\n     * order of choice instead of always x,y,z order as we do here.\n     */\n    _calculateMatrix () {\n        let matrix = new window.DOMMatrix\n\n        let alignAdjustment = [0,0,0]\n        if (this._parent) { // The root Scene doesn't have a parent, for example.\n            let parentSize = this._parent.actualSize\n            alignAdjustment[0] = parentSize.x * this._properties.align.x\n            alignAdjustment[1] = parentSize.y * this._properties.align.y\n            alignAdjustment[2] = parentSize.z * this._properties.align.z\n        }\n\n        let mountPointAdjustment = [0,0,0]\n        let thisSize = this.actualSize\n        mountPointAdjustment[0] = thisSize.x * this._properties.mountPoint.x\n        mountPointAdjustment[1] = thisSize.y * this._properties.mountPoint.y\n        mountPointAdjustment[2] = thisSize.z * this._properties.mountPoint.z\n\n        let appliedPosition = []\n        appliedPosition[0] = this._properties.position.x + alignAdjustment[0] - mountPointAdjustment[0]\n        appliedPosition[1] = this._properties.position.y + alignAdjustment[1] - mountPointAdjustment[1]\n        appliedPosition[2] = this._properties.position.z + alignAdjustment[2] - mountPointAdjustment[2]\n\n        matrix.translateSelf(appliedPosition[0], appliedPosition[1], appliedPosition[2])\n\n        // TODO: move by negative origin before rotating.\n        // XXX Should we calculate origin here, or should we leave that to the\n        // DOM renderer (in the style property)? WebGL renderer will need\n        // manual calculations. Maybe we don't do it here, and delegate it to\n        // DOM and WebGL renderers.\n\n        // apply each axis rotation, in the x,y,z order.\n        // XXX: Does order in which axis rotations are applied matter? If so,\n        // which order is best? Maybe we let the user decide (with our\n        // recommendation)?\n        let rotation = this._properties.rotation\n        matrix.rotateAxisAngleSelf(1,0,0, rotation.x)\n        matrix.rotateAxisAngleSelf(0,1,0, rotation.y)\n        matrix.rotateAxisAngleSelf(0,0,1, rotation.z)\n\n        // TODO: move by positive origin after rotating.\n\n        return matrix\n    }\n\n    /**\n     * Apply the DOMMatrix value to the style of this Node's element.\n     *\n     * @private\n     *\n     * TODO We'll eventually apply the DOMMatrix directly instead of\n     * converting to a string here.\n     */\n    _applyTransform () {\n        var matrix = this._properties.transform;\n\n        // XXX: is this in the right order? UPDATE: It is.\n        // TODO: Apply DOMMatrix directly to the Element once browser APIs\n        // support it. Maybe we can polyfill this?\n        var cssMatrixString = `matrix3d(\n            ${ matrix.m11 },\n            ${ matrix.m12 },\n            ${ matrix.m13 },\n            ${ matrix.m14 },\n            ${ matrix.m21 },\n            ${ matrix.m22 },\n            ${ matrix.m23 },\n            ${ matrix.m24 },\n            ${ matrix.m31 },\n            ${ matrix.m32 },\n            ${ matrix.m33 },\n            ${ matrix.m34 },\n            ${ matrix.m41 },\n            ${ matrix.m42 },\n            ${ matrix.m43 },\n            ${ matrix.m44 }\n        )`;\n\n        this._applyStyle('transform', cssMatrixString);\n    }\n\n    /**\n     * [applyStyle description]\n     *\n     * @method\n     * @private\n     * @memberOf Node\n     * @param  {String} property [description]\n     * @param  {String} value    [description]\n     */\n    _applyStyles () {\n        for (let key of Object.keys(this._properties.style)) {\n            this._applyStyle(key, this._properties.style[key]);\n        }\n    }\n\n    /**\n     * Apply a style property to this node's element.\n     *\n     * TODO: this will be moved into DOMRenderer.\n     *\n     * @private\n     * @param  {string} property The CSS property we will a apply.\n     * @param  {string} value    The value the CSS property wil have.\n     */\n    _applyStyle (property, value) {\n        this._el.element.style[property] = value;\n    }\n\n    /**\n     * [setMatrix3d description]\n     *\n     * @private\n     * @param {DOMMatrix} matrix A DOMMatrix instance to set as this node's\n     * transform. See \"W3C Geometry Interfaces\".\n     */\n    _setMatrix3d (matrix) {\n        this._properties.transform = matrix\n        // ^ TODO PERFORMANCE: What's faster? Setting a new DOMMatrix (as we do here\n        // currently, the result of _calculateMatrix) or applying all\n        // transform values to the existing DOMMatrix?\n\n        this._applyTransform();\n    }\n}\n\nfunction defaultZeros(array) {\n    array[0] = array[0] || 0\n    array[1] = array[1] || 0\n    array[2] = array[2] || 0\n    return array\n}\n\nfunction isRealNumber(num) {\n    if (\n        typeof num != 'number'\n        || Object.is(num, NaN)\n        || Object.is(num, Infinity)\n    ) return false\n    return true\n}\n"]}