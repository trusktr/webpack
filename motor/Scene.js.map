{"version":3,"sources":["../src/motor/Scene.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AACA;;;;AAEA;;;;;;AAEA,QAAQ,GAAR,CAAY,oBAAZ;;IAGM,K;;;AACF,mBAAY,eAAZ,EAA6B;AAAA;;AACzB,gBAAQ,GAAR,CAAY,wBAAZ;;AADyB,mHAEnB,EAFmB,EAEf,eAFe;;AAIzB,cAAK,MAAL;AACA,cAAK,oBAAL;;;AAGA,cAAK,WAAL,CAAiB,QAAjB,GAA4B,EAAE,GAAG,cAAL,EAAqB,GAAG,cAAxB,EAAwC,GAAG,cAA3C,EAA5B;AARyB;AAS5B;;;;gCAEO;AACJ;AACH;;;uCAEc;AACX,mBAAO,qBAAP;AACH;;;;;;;;;;;;;;;;mGAYW,U;oBAcA,Q;;;;;;uCAXF,8B;;;;;;;AAKN,oCAAI,CAAC,UAAL,EAAiB;AACb,iDAAa,SAAS,IAAtB;AACH;;;AAFD,qCAKK,IAAI,OAAO,UAAP,KAAsB,QAA1B,EAAoC;AACjC,gDADiC,GACtB,UADsB;;AAErC,qDAAa,SAAS,aAAT,CAAuB,QAAvB,CAAb;AACH;;;;sCAGG,sBAAsB,OAAO,W;;;;;AAC7B,oCAAI,eAAe,KAAK,GAAL,CAAS,OAAT,CAAiB,UAApC,EACI,WAAW,WAAX,CAAuB,KAAK,GAAL,CAAS,OAAhC;;AAEJ,qCAAK,QAAL,GAAgB,IAAhB;;;;;sCAGM,IAAI,KAAJ,CAAU,yGAAV,C;;;;AAGV,qCAAK,oBAAL,CAA0B,KAAK,QAA/B;;;;;;;;;;;;;;;;;;;;;;;;kCAOM;AAAA;;AACN,iBAAK,GAAL,CAAS,OAAT,CAAiB,UAAjB,CAA4B,WAA5B,CAAwC,KAAK,GAAL,CAAS,OAAjD;AACA,iBAAK,QAAL,GAAgB,KAAhB;;;AAGA,iBAAK,aAAL,GAAqB,sBAAY;AAAA,uBAAK,OAAK,oBAAL,GAA4B,CAAjC;AAAA,aAAZ,CAArB;AACH;;;;;kBAxEC,K","file":"Scene.js","sourcesContent":["import Node from './Node'\nimport documentReady from 'awaitbox/dom/documentReady'\n\nimport MotorHTMLScene from '../motor-html/scene'\n\nconsole.log(' --- Scene module!', Node)\n\nexport default\nclass Scene extends Node {\n    constructor(_motorHtmlScene) {\n        console.log(' --- Scene constructor')\n        super({}, _motorHtmlScene)\n\n        this._scene = this\n        this._resolveScenePromise(this)\n\n        // For now, Scenes are always proportionally sized by default.\n        this._properties.sizeMode = { x: 'proportional', y: 'proportional', z: 'proportional' }\n    }\n\n    _init() {\n        super._init()\n    }\n\n    _makeElement() {\n        return new MotorHTMLScene\n    }\n\n    /**\n     * Mount the scene into the given target.\n     * Resolves the Scene's mountPromise, which can be use to do something once\n     * the scene is mounted.\n     *\n     * @param {string|HTMLElement} [mountPoint=document.body] If a string selector is provided,\n     * the mount point will be selected from the DOM. If an HTMLElement is\n     * provided, that will be the mount point. If no mount point is provided,\n     * the scene will be mounted into document.body.\n     */\n    async mount(mountPoint) {\n        // Wait for the document to be ready before mounting, otherwise the\n        // target mount point might not exist yet when this function is called.\n        await documentReady()\n\n        // if no mountPoint was provided, just mount onto the <body> element.\n        // XXX: Maybe we should just not mount the scene if no mountPoint is\n        // provided, and expose a mount method.\n        if (!mountPoint) {\n            mountPoint = document.body\n        }\n\n        // if the user supplied a selector, mount there.\n        else if (typeof mountPoint === 'string') {\n            let selector = mountPoint\n            mountPoint = document.querySelector(selector)\n        }\n\n        // if we have an actual mount point (the user may have supplied one)\n        if (mountPoint instanceof window.HTMLElement) {\n            if (mountPoint !== this._el.element.parentNode)\n                mountPoint.appendChild(this._el.element)\n\n            this._mounted = true\n        }\n        else {\n            throw new Error('Invalid mount point specified in Scene.mount() call. Specify a selector, or pass an actual HTMLElement.')\n        }\n\n        this._resolveMountPromise(this._mounted)\n    }\n\n    /**\n     * Unmount the scene from it's mount point. Resets the Scene's\n     * mountPromise.\n     */\n    unmount() {\n        this._el.element.parentNode.removeChild(this._el.element)\n        this._mounted = false\n\n        // a new promise to be resolved on the next mount.\n        this._mountPromise = new Promise(r => this._resolveMountPromise = r)\n    }\n\n}\n"]}